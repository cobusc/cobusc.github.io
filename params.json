{"name":"cobusc.github.com","tagline":"GitHub user site","body":"### Welcome to GitHub Pages.\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:\r\n\r\n```\r\n$ cd your_repo_root/repo_name\r\n$ git fetch origin\r\n$ git checkout gh-pages\r\n```\r\n\r\nIf you're using the GitHub for Mac, simply sync your repository and you'll see the new branch.\r\n\r\n### Designer Templates\r\nWe've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.\r\n\r\n### Rather Drive Stick?\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out the documentation at http://help.github.com/pages or contact support@github.com and weâ€™ll help you sort it out.\r\n\r\n\r\ncobusc.github.com\r\n=================\r\n\r\nGitHub user site\r\n\r\nSome code to test GFM:\r\n\r\n```erlang\r\n%% Generated by codegen_tool\r\n%% %% vim: syntax=erlang\r\n\r\n-module(queue_utils).\r\n-compile({parse_transform, autohelp}).\r\n-export([\r\n         make_bulk_account_queue_name/2, make_application_queue_name/1,\r\n         make_bulk_account_cons_name/3, make_application_cons_name/2,\r\n         make_bulk_account_dlq_name/2, make_application_dlq_name/1,\r\n         make_bulk_account_dlq_cons_name/2, make_application_dlq_cons_name/1,\r\n\r\n         make_bulk_account_queues_specs/3, make_application_queues_specs/2,\r\n         make_bulk_account_cons_spec/3, make_application_cons_spec/2,\r\n\r\n         get_bulk_account_ids/0,\r\n\r\n         list_application_queue_types/0,\r\n         list_bulk_account_queue_types/0\r\n        ]).\r\n-include(\"queue_definitions.hrl\").\r\n\r\n%%\r\n%% @doc Get a list of bulk_account IDs via the callback defined in the application config\r\n%%\r\n%% NOTE: This is not the right place for this function. It needs to be defined somewhere else.\r\n%%\r\n-spec get_bulk_account_ids() -> {ok, list(binaryOrString())}.\r\n\r\nget_bulk_account_ids() ->\r\n    {ok, {Module, Function, Arguments}} = application:get_env(mira_test, bulk_account_ids_callback),\r\n    {ok, _} = erlang:apply(Module, Function, Arguments).\r\n\r\n%%\r\n%% @doc List the application queue types\r\n%%\r\n-spec list_application_queue_types() -> ok.\r\n\r\nlist_application_queue_types() ->\r\n    list_queue_types(\"APPLICATION Queue Types\", [Q || {Q, _W} <- ?ALL_APPLICATION_QUEUE_TYPES]).\r\n            \r\n%%\r\n%% @doc List the bulk_account queue types\r\n%%\r\n-spec list_bulk_account_queue_types() -> ok.\r\n\r\nlist_bulk_account_queue_types() ->\r\n    list_queue_types(\"BULK_ACCOUNT Queue Types\", [Q || {Q, _W} <- ?ALL_BULK_ACCOUNT_QUEUE_TYPES]).\r\n\r\n\r\n-spec list_queue_types(Heading::string(), QueueTypes::list(binaryOrString())) -> ok.\r\n\r\nlist_queue_types(Heading, QueueTypes) ->\r\n    io:format(\"~s~n========================~n\", [Heading]),\r\n    PrintFun = fun (QueueType) ->\r\n        io:format(\"~s~n\", [QueueType])\r\n    end,\r\n    ok = lists:foreach(PrintFun, QueueTypes),\r\n    io:format(\"========================~n\", []).\r\n\r\n%%\r\n%% ==================================================\r\n%% Bulk_account queue components name generation\r\n%% ==================================================\r\n%%\r\n\r\n%%\r\n%% @doc Bulk_account queue name generation\r\n%%\r\n-spec make_bulk_account_queue_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().\r\n\r\nmake_bulk_account_queue_name(Type, Id) ->\r\n    make_atom(\"~s_~s\", [Type, Id]).\r\n\r\n%%\r\n%% @doc Bulk_account queue consumer name generation\r\n%%\r\n-spec make_bulk_account_cons_name(Type::binaryOrString(), Id::binaryOrString(), Index::non_neg_integer()) -> atom().\r\n\r\nmake_bulk_account_cons_name(Type, Id, Index) ->\r\n    make_atom(\"~s_cons_~s_~B\", [Type, Id, Index]).\r\n\r\n%%\r\n%% @doc Bulk_account queue DLQ name generation\r\n%%\r\n-spec make_bulk_account_dlq_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().\r\n\r\nmake_bulk_account_dlq_name(Type, Id) ->\r\n    make_atom(\"~s_dlq_~s\", [Type, Id]).\r\n\r\n%%\r\n%% @doc Bulk_account queue DLQ consumer name generation\r\n%%\r\n-spec make_bulk_account_dlq_cons_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().\r\n\r\nmake_bulk_account_dlq_cons_name(Type, Id) ->\r\n    make_atom(\"~s_dlq_cons_~s\", [Type, Id]).\r\n\r\n%%\r\n%% ============================================\r\n%% Application queue components name generation\r\n%% ============================================\r\n%% \r\n\r\n%%\r\n%% @doc Application queue name generation\r\n%%\r\n-spec make_application_queue_name(Type::binaryOrString()) -> atom().\r\n\r\nmake_application_queue_name(Type) ->\r\n    make_bulk_account_queue_name(Type, ?APPLICATION_QUEUE).\r\n\r\n%%\r\n%% @doc Application consumer name generation.\r\n%%\r\n-spec make_application_cons_name(Type::binaryOrString(), Index::non_neg_integer()) -> atom().\r\n\r\nmake_application_cons_name(Type, Index) ->\r\n    make_bulk_account_cons_name(Type, ?APPLICATION_QUEUE, Index).\r\n\r\n%%\r\n%% @doc Application queue DLQ name generation.\r\n%%\r\n-spec make_application_dlq_name(Type::binaryOrString()) -> atom().\r\n\r\nmake_application_dlq_name(Type) ->\r\n    make_bulk_account_dlq_name(Type, ?APPLICATION_QUEUE).\r\n\r\n%%\r\n%% @doc Application queue DLQ consumer name generation.\r\n%%\r\n-spec make_application_dlq_cons_name(Type::binaryOrString()) -> atom().\r\n\r\nmake_application_dlq_cons_name(Type) ->\r\n    make_bulk_account_dlq_cons_name(Type, ?APPLICATION_QUEUE).\r\n\r\n%%\r\n%% @doc Bulk_account queue consumer spec generation.\r\n%%\r\n-spec make_bulk_account_cons_spec(Type::binaryOrString(), Id::binaryOrString(), Index::non_neg_integer()) -> \r\n    {\r\n     #bulk_account_consumer{},\r\n     {eroq_consumer, start_link, [any(), ...]},\r\n     permanent, 5000, worker, [eroq_consumer]\r\n    }.\r\n\r\nmake_bulk_account_cons_spec(Type, Id, Index) ->\r\n    QueueName = make_bulk_account_queue_name(Type, Id),\r\n    DlqName = make_bulk_account_dlq_name(Type, Id),\r\n    WorkerName = make_atom(\"~s_worker\", [Type]),\r\n    ConsumerName = make_bulk_account_cons_name(Type, Id, Index),\r\n    Prefix =\r\n    case is_binary(Type) of\r\n        true -> binary_to_list(Type);\r\n        false -> Type\r\n    end,\r\n    {\r\n     #bulk_account_consumer{type=Type, id=Id, index=Index},\r\n     {eroq_consumer, start_link, [ConsumerName, Prefix++\"_cons\", QueueName, DlqName, WorkerName, process, [Id], active, false]},\r\n     permanent, 5000, worker, [eroq_consumer]\r\n    }.\r\n\r\n    \r\n%%\r\n%% @doc Application queue consumer spec generation.\r\n%%\r\n-spec make_application_cons_spec(Type::binaryOrString(), Index::non_neg_integer()) -> \r\n    {\r\n     #application_consumer{},\r\n     {eroq_consumer, start_link, [any(), ...]},\r\n     permanent, 5000, worker, [eroq_consumer]\r\n    }.\r\n\r\nmake_application_cons_spec(Type, Index) ->\r\n    QueueName = make_application_queue_name(Type),\r\n    DlqName = make_application_dlq_name(Type),\r\n    WorkerName = make_atom(\"~s_worker\", [Type]),\r\n    ConsumerName = make_application_cons_name(Type, Index),\r\n    Prefix = \r\n    case is_binary(Type) of\r\n        true -> binary_to_list(Type);\r\n        false -> Type\r\n    end,\r\n    {\r\n     #application_consumer{type=Type, index=Index},\r\n     {eroq_consumer, start_link, [ConsumerName, Prefix++\"_cons\", QueueName, DlqName, WorkerName, process, [], active, false]},\r\n     permanent, 5000, worker, [eroq_consumer]\r\n    }.\r\n\r\n%%\r\n%% @doc Make specs for bulk_account queue, DLQ, consumer and DLQ consumer.\r\n%%\r\n%% It is expected that the worker on these queues will:\r\n%% [1] be named Type++\"_worker\", and\r\n%% [2] export a process/3 function.\r\n%%\r\n-spec make_bulk_account_queues_specs(Type::binaryOrString(), Id::binaryOrString(), NumConsumers::non_neg_integer()) ->\r\n    [{tuple(),{'eroq_consumer','start_link',[any(),...]} | \r\n             {'eroq_dlq_consumer','start_link',[any(),...]} | \r\n             {'eroq_queue','start_link',[any(),...]},\r\n              'permanent',5000,'worker',\r\n             ['eroq_consumer' | 'eroq_dlq_consumer' | 'eroq_queue',...]},...].\r\n\r\nmake_bulk_account_queues_specs(Type, Id, NumConsumers) \r\nwhen is_integer(NumConsumers), NumConsumers > 0 ->\r\n    QueueName = make_bulk_account_queue_name(Type, Id),\r\n    DlqName = make_bulk_account_dlq_name(Type, Id),\r\n    DlqConsumerName = make_bulk_account_dlq_cons_name(Type, Id),\r\n\r\n    StringType =\r\n    case is_binary(Type) of\r\n        true -> binary_to_list(Type);\r\n        false -> Type\r\n    end,\r\n\r\n    QueueSpec =  { \r\n        {queue, Type, Id}, \r\n        {eroq_queue, start_link, [QueueName, StringType, false]},\r\n        permanent, 5000, worker, [eroq_queue]\r\n    },\r\n\r\n    DlqSpec = { \r\n        {dlq, Type, Id}, \r\n        {eroq_queue, start_link, [DlqName, StringType++\"_dlq\", false]},\r\n        permanent, 5000, worker, [eroq_queue]\r\n    },\r\n\r\n    ConsSpecs = [make_bulk_account_cons_spec(Type, Id, Index) || Index <- lists:seq(1, NumConsumers)],\r\n\r\n    DlqConsumerSpec = { \r\n        {dlq_consumer, Type, Id}, \r\n        {eroq_dlq_consumer, start_link, [DlqConsumerName, StringType++\"_dlq_cons\", DlqName, recovery_worker, dlq_requeue, []]},\r\n        permanent, 5000, worker, [eroq_dlq_consumer]\r\n    },\r\n\r\n    [ QueueSpec, DlqSpec, DlqConsumerSpec ] ++ ConsSpecs.\r\n\r\n\r\n%%\r\n%% @doc Make specs for application queue, DLQ, consumer and DLQ consumer.\r\n%%\r\n%% It is expected that the worker on these queues will:\r\n%% [1] be named Type++\"_worker\", and\r\n%% [2] export a process/3 function.\r\n%%\r\n-spec make_application_queues_specs(Type::binaryOrString(), NumConsumers::non_neg_integer()) -> \r\n    [{tuple(),{'eroq_consumer','start_link',[any(),...]} | \r\n              {'eroq_dlq_consumer','start_link',[any(),...]} | \r\n              {'eroq_queue','start_link',[any(),...]},\r\n               'permanent',5000,'worker',\r\n              ['eroq_consumer' | 'eroq_dlq_consumer' | 'eroq_queue',...]},...].\r\n\r\nmake_application_queues_specs(Type, NumConsumers) \r\nwhen is_integer(NumConsumers), NumConsumers > 0 ->\r\n    QueueName = make_application_queue_name(Type),\r\n    DlqName = make_application_dlq_name(Type),\r\n    DlqConsumerName = make_application_dlq_cons_name(Type),\r\n\r\n    StringType =\r\n    case is_binary(Type) of\r\n        true -> binary_to_list(Type);\r\n        false -> Type\r\n    end,\r\n\r\n    QueueSpec =  { \r\n        {queue, Type}, \r\n        {eroq_queue, start_link, [QueueName, StringType, false]},\r\n        permanent, 5000, worker, [eroq_queue]\r\n    },\r\n\r\n    DlqSpec = { \r\n        {dlq, Type}, \r\n        {eroq_queue, start_link, [DlqName, StringType++\"_dlq\", false]},\r\n        permanent, 5000, worker, [eroq_queue]\r\n    },\r\n\r\n    ConsSpecs = [make_application_cons_spec(Type, Index) || Index <- lists:seq(1, NumConsumers)],\r\n\r\n    DlqConsumerSpec = { \r\n        {dlq_consumer, Type}, \r\n        {eroq_dlq_consumer, start_link, [DlqConsumerName, StringType++\"_dlq_cons\", DlqName, recovery_worker, dlq_requeue, []]},\r\n        permanent, 5000, worker, [eroq_dlq_consumer]\r\n    },\r\n\r\n    [ QueueSpec, DlqSpec, DlqConsumerSpec ] ++ ConsSpecs.\r\n\r\n%%\r\n%% @doc Helper function to build atoms used as queue names, etc \r\n%%\r\n-spec make_atom(Format::string(), Args::list(any())) -> atom().\r\n\r\nmake_atom(Format, Args) ->\r\n    list_to_atom(lists:flatten(io_lib:format(Format, Args))).\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}