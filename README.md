cobusc.github.io
================

Hey, look. Tables!


| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |


Markdown | Less | Pretty
--- | --- | ---
*Still* | `renders` | **nicely**
1 | 2 | 3


Some code to test GFM:

```erlang
%% Generated by codegen_tool
%% %% vim: syntax=erlang

-module(queue_utils).
-compile({parse_transform, autohelp}).
-export([
         make_bulk_account_queue_name/2, make_application_queue_name/1,
         make_bulk_account_cons_name/3, make_application_cons_name/2,
         make_bulk_account_dlq_name/2, make_application_dlq_name/1,
         make_bulk_account_dlq_cons_name/2, make_application_dlq_cons_name/1,

         make_bulk_account_queues_specs/3, make_application_queues_specs/2,
         make_bulk_account_cons_spec/3, make_application_cons_spec/2,

         get_bulk_account_ids/0,

         list_application_queue_types/0,
         list_bulk_account_queue_types/0
        ]).
-include("queue_definitions.hrl").

%%
%% @doc Get a list of bulk_account IDs via the callback defined in the application config
%%
%% NOTE: This is not the right place for this function. It needs to be defined somewhere else.
%%
-spec get_bulk_account_ids() -> {ok, list(binaryOrString())}.

get_bulk_account_ids() ->
    {ok, {Module, Function, Arguments}} = application:get_env(mira_test, bulk_account_ids_callback),
    {ok, _} = erlang:apply(Module, Function, Arguments).

%%
%% @doc List the application queue types
%%
-spec list_application_queue_types() -> ok.

list_application_queue_types() ->
    list_queue_types("APPLICATION Queue Types", [Q || {Q, _W} <- ?ALL_APPLICATION_QUEUE_TYPES]).
            
%%
%% @doc List the bulk_account queue types
%%
-spec list_bulk_account_queue_types() -> ok.

list_bulk_account_queue_types() ->
    list_queue_types("BULK_ACCOUNT Queue Types", [Q || {Q, _W} <- ?ALL_BULK_ACCOUNT_QUEUE_TYPES]).


-spec list_queue_types(Heading::string(), QueueTypes::list(binaryOrString())) -> ok.

list_queue_types(Heading, QueueTypes) ->
    io:format("~s~n========================~n", [Heading]),
    PrintFun = fun (QueueType) ->
        io:format("~s~n", [QueueType])
    end,
    ok = lists:foreach(PrintFun, QueueTypes),
    io:format("========================~n", []).

%%
%% ==================================================
%% Bulk_account queue components name generation
%% ==================================================
%%

%%
%% @doc Bulk_account queue name generation
%%
-spec make_bulk_account_queue_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().

make_bulk_account_queue_name(Type, Id) ->
    make_atom("~s_~s", [Type, Id]).

%%
%% @doc Bulk_account queue consumer name generation
%%
-spec make_bulk_account_cons_name(Type::binaryOrString(), Id::binaryOrString(), Index::non_neg_integer()) -> atom().

make_bulk_account_cons_name(Type, Id, Index) ->
    make_atom("~s_cons_~s_~B", [Type, Id, Index]).

%%
%% @doc Bulk_account queue DLQ name generation
%%
-spec make_bulk_account_dlq_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().

make_bulk_account_dlq_name(Type, Id) ->
    make_atom("~s_dlq_~s", [Type, Id]).

%%
%% @doc Bulk_account queue DLQ consumer name generation
%%
-spec make_bulk_account_dlq_cons_name(Type::binaryOrString(), Id::binaryOrString()) -> atom().

make_bulk_account_dlq_cons_name(Type, Id) ->
    make_atom("~s_dlq_cons_~s", [Type, Id]).

%%
%% ============================================
%% Application queue components name generation
%% ============================================
%% 

%%
%% @doc Application queue name generation
%%
-spec make_application_queue_name(Type::binaryOrString()) -> atom().

make_application_queue_name(Type) ->
    make_bulk_account_queue_name(Type, ?APPLICATION_QUEUE).

%%
%% @doc Application consumer name generation.
%%
-spec make_application_cons_name(Type::binaryOrString(), Index::non_neg_integer()) -> atom().

make_application_cons_name(Type, Index) ->
    make_bulk_account_cons_name(Type, ?APPLICATION_QUEUE, Index).

%%
%% @doc Application queue DLQ name generation.
%%
-spec make_application_dlq_name(Type::binaryOrString()) -> atom().

make_application_dlq_name(Type) ->
    make_bulk_account_dlq_name(Type, ?APPLICATION_QUEUE).

%%
%% @doc Application queue DLQ consumer name generation.
%%
-spec make_application_dlq_cons_name(Type::binaryOrString()) -> atom().

make_application_dlq_cons_name(Type) ->
    make_bulk_account_dlq_cons_name(Type, ?APPLICATION_QUEUE).

%%
%% @doc Bulk_account queue consumer spec generation.
%%
-spec make_bulk_account_cons_spec(Type::binaryOrString(), Id::binaryOrString(), Index::non_neg_integer()) -> 
    {
     #bulk_account_consumer{},
     {eroq_consumer, start_link, [any(), ...]},
     permanent, 5000, worker, [eroq_consumer]
    }.

make_bulk_account_cons_spec(Type, Id, Index) ->
    QueueName = make_bulk_account_queue_name(Type, Id),
    DlqName = make_bulk_account_dlq_name(Type, Id),
    WorkerName = make_atom("~s_worker", [Type]),
    ConsumerName = make_bulk_account_cons_name(Type, Id, Index),
    Prefix =
    case is_binary(Type) of
        true -> binary_to_list(Type);
        false -> Type
    end,
    {
     #bulk_account_consumer{type=Type, id=Id, index=Index},
     {eroq_consumer, start_link, [ConsumerName, Prefix++"_cons", QueueName, DlqName, WorkerName, process, [Id], active, false]},
     permanent, 5000, worker, [eroq_consumer]
    }.

    
%%
%% @doc Application queue consumer spec generation.
%%
-spec make_application_cons_spec(Type::binaryOrString(), Index::non_neg_integer()) -> 
    {
     #application_consumer{},
     {eroq_consumer, start_link, [any(), ...]},
     permanent, 5000, worker, [eroq_consumer]
    }.

make_application_cons_spec(Type, Index) ->
    QueueName = make_application_queue_name(Type),
    DlqName = make_application_dlq_name(Type),
    WorkerName = make_atom("~s_worker", [Type]),
    ConsumerName = make_application_cons_name(Type, Index),
    Prefix = 
    case is_binary(Type) of
        true -> binary_to_list(Type);
        false -> Type
    end,
    {
     #application_consumer{type=Type, index=Index},
     {eroq_consumer, start_link, [ConsumerName, Prefix++"_cons", QueueName, DlqName, WorkerName, process, [], active, false]},
     permanent, 5000, worker, [eroq_consumer]
    }.

%%
%% @doc Make specs for bulk_account queue, DLQ, consumer and DLQ consumer.
%%
%% It is expected that the worker on these queues will:
%% [1] be named Type++"_worker", and
%% [2] export a process/3 function.
%%
-spec make_bulk_account_queues_specs(Type::binaryOrString(), Id::binaryOrString(), NumConsumers::non_neg_integer()) ->
    [{tuple(),{'eroq_consumer','start_link',[any(),...]} | 
             {'eroq_dlq_consumer','start_link',[any(),...]} | 
             {'eroq_queue','start_link',[any(),...]},
              'permanent',5000,'worker',
             ['eroq_consumer' | 'eroq_dlq_consumer' | 'eroq_queue',...]},...].

make_bulk_account_queues_specs(Type, Id, NumConsumers) 
when is_integer(NumConsumers), NumConsumers > 0 ->
    QueueName = make_bulk_account_queue_name(Type, Id),
    DlqName = make_bulk_account_dlq_name(Type, Id),
    DlqConsumerName = make_bulk_account_dlq_cons_name(Type, Id),

    StringType =
    case is_binary(Type) of
        true -> binary_to_list(Type);
        false -> Type
    end,

    QueueSpec =  { 
        {queue, Type, Id}, 
        {eroq_queue, start_link, [QueueName, StringType, false]},
        permanent, 5000, worker, [eroq_queue]
    },

    DlqSpec = { 
        {dlq, Type, Id}, 
        {eroq_queue, start_link, [DlqName, StringType++"_dlq", false]},
        permanent, 5000, worker, [eroq_queue]
    },

    ConsSpecs = [make_bulk_account_cons_spec(Type, Id, Index) || Index <- lists:seq(1, NumConsumers)],

    DlqConsumerSpec = { 
        {dlq_consumer, Type, Id}, 
        {eroq_dlq_consumer, start_link, [DlqConsumerName, StringType++"_dlq_cons", DlqName, recovery_worker, dlq_requeue, []]},
        permanent, 5000, worker, [eroq_dlq_consumer]
    },

    [ QueueSpec, DlqSpec, DlqConsumerSpec ] ++ ConsSpecs.


%%
%% @doc Make specs for application queue, DLQ, consumer and DLQ consumer.
%%
%% It is expected that the worker on these queues will:
%% [1] be named Type++"_worker", and
%% [2] export a process/3 function.
%%
-spec make_application_queues_specs(Type::binaryOrString(), NumConsumers::non_neg_integer()) -> 
    [{tuple(),{'eroq_consumer','start_link',[any(),...]} | 
              {'eroq_dlq_consumer','start_link',[any(),...]} | 
              {'eroq_queue','start_link',[any(),...]},
               'permanent',5000,'worker',
              ['eroq_consumer' | 'eroq_dlq_consumer' | 'eroq_queue',...]},...].

make_application_queues_specs(Type, NumConsumers) 
when is_integer(NumConsumers), NumConsumers > 0 ->
    QueueName = make_application_queue_name(Type),
    DlqName = make_application_dlq_name(Type),
    DlqConsumerName = make_application_dlq_cons_name(Type),

    StringType =
    case is_binary(Type) of
        true -> binary_to_list(Type);
        false -> Type
    end,

    QueueSpec =  { 
        {queue, Type}, 
        {eroq_queue, start_link, [QueueName, StringType, false]},
        permanent, 5000, worker, [eroq_queue]
    },

    DlqSpec = { 
        {dlq, Type}, 
        {eroq_queue, start_link, [DlqName, StringType++"_dlq", false]},
        permanent, 5000, worker, [eroq_queue]
    },

    ConsSpecs = [make_application_cons_spec(Type, Index) || Index <- lists:seq(1, NumConsumers)],

    DlqConsumerSpec = { 
        {dlq_consumer, Type}, 
        {eroq_dlq_consumer, start_link, [DlqConsumerName, StringType++"_dlq_cons", DlqName, recovery_worker, dlq_requeue, []]},
        permanent, 5000, worker, [eroq_dlq_consumer]
    },

    [ QueueSpec, DlqSpec, DlqConsumerSpec ] ++ ConsSpecs.

%%
%% @doc Helper function to build atoms used as queue names, etc 
%%
-spec make_atom(Format::string(), Args::list(any())) -> atom().

make_atom(Format, Args) ->
    list_to_atom(lists:flatten(io_lib:format(Format, Args))).
```

